-- PostgreSQL schema for NebulaChat (DDL + basic seed data)
-- Requires pgcrypto for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Enums
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'message_status') THEN
CREATE TYPE message_status AS ENUM ('sending', 'sent', 'error');
END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_status') THEN
CREATE TYPE user_status AS ENUM ('online', 'offline', 'busy');
END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'chat_type') THEN
CREATE TYPE chat_type AS ENUM ('channel', 'direct');
END IF;
END$$;

-- Users table (frontend needs username, avatar, status)
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username TEXT NOT NULL UNIQUE,
    display_name TEXT,           -- optional friendly name
    avatar TEXT,                 -- avatar string used by frontend (initials or URL)
    status user_status DEFAULT 'offline',
    created_at TIMESTAMPTZ DEFAULT now(),
    last_seen TIMESTAMPTZ
    );

-- Chat sessions (channels / direct)
-- frontend uses ids like 'general' ; keep id as TEXT to allow stable strings
CREATE TABLE IF NOT EXISTS chat_sessions (
                                             id TEXT PRIMARY KEY,         -- e.g. 'general', 'tech' or UUID for autogenerated sessions
                                             name TEXT NOT NULL,
                                             type chat_type NOT NULL,
                                             description TEXT,
                                             avatar TEXT,
                                             status user_status,          -- optional status for DMs
                                             is_public BOOLEAN DEFAULT TRUE,
                                             metadata JSONB,
                                             created_at TIMESTAMPTZ DEFAULT now()
    );

-- Participants for direct messages and channels membership
CREATE TABLE IF NOT EXISTS chat_participants (
                                                 id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    chat_session_id TEXT NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    is_admin BOOLEAN DEFAULT FALSE,
    joined_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(chat_session_id, user_id)
    );

-- Messages
CREATE TABLE IF NOT EXISTS messages (
                                        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    chat_session_id TEXT NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES users(id), -- nullable for 'System' or external AI
    sender_name TEXT NOT NULL,          -- store display/sender name (e.g., 'System', 'Nova')
    text TEXT,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT now(), -- corresponds to frontend Date
    status message_status DEFAULT 'sent',
    avatar TEXT,                          -- optional: per-message avatar/initials
    metadata JSONB,                       -- for storing extra info (reactions, flags)
    reply_to UUID REFERENCES messages(id),
    created_at TIMESTAMPTZ DEFAULT now()
    );

-- Attachments (frontend sends base64 data URLs; backend can store as bytea or external URL)
CREATE TABLE IF NOT EXISTS attachments (
                                           id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    content_type TEXT,
    size INTEGER,
    data BYTEA,        -- binary data (optional). If you prefer storing base64 text, use data_base64 TEXT
    data_base64 TEXT,  -- keep this optional to directly store frontend dataURL if required
    url TEXT,          -- recommended: link to object storage (S3/GCS) if uploaded externally
    created_at TIMESTAMPTZ DEFAULT now()
    );

-- Indexes for efficient reads
CREATE INDEX IF NOT EXISTS idx_messages_session_time ON messages (chat_session_id, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_messages_sender ON messages (sender_id);
CREATE INDEX IF NOT EXISTS idx_attachments_message ON attachments (message_id);
CREATE INDEX IF NOT EXISTS idx_chat_participants_user ON chat_participants (user_id);

-- Optional full-text search field for messages (if you want quick message search)
ALTER TABLE IF EXISTS messages
    ADD COLUMN IF NOT EXISTS tsv tsvector;

CREATE INDEX IF NOT EXISTS idx_messages_tsv ON messages USING GIN (tsv);

-- Trigger to maintain tsv automatically (simple example)
CREATE FUNCTION messages_tsv_trigger() RETURNS trigger LANGUAGE plpgsql AS $$
begin
  new.tsv :=
    to_tsvector('simple', coalesce(new.text, '')) ||
    to_tsvector('simple', coalesce(new.sender_name, ''));
return new;
end
$$;

DROP TRIGGER IF EXISTS trg_messages_tsv ON messages;
CREATE TRIGGER trg_messages_tsv
    BEFORE INSERT OR UPDATE ON messages
                         FOR EACH ROW EXECUTE FUNCTION messages_tsv_trigger();

-- Basic seed data matching frontend dummy channels & users
-- Users (Nova, Cosmo_Bot, Orion7, System)
INSERT INTO users (id, username, display_name, avatar, status)
VALUES
    (gen_random_uuid(), 'Nova', 'Nova', 'NO', 'online')
    ON CONFLICT (username) DO NOTHING;

INSERT INTO users (id, username, display_name, avatar, status)
VALUES
    (gen_random_uuid(), 'Cosmo_Bot', 'Cosmo_Bot', 'CB', 'busy')
    ON CONFLICT (username) DO NOTHING;

INSERT INTO users (id, username, display_name, avatar, status)
VALUES
    (gen_random_uuid(), 'Orion7', 'Orion7', 'OR', 'offline')
    ON CONFLICT (username) DO NOTHING;

INSERT INTO users (id, username, display_name, avatar, status)
VALUES
    (gen_random_uuid(), 'System', 'System', NULL, 'offline')
    ON CONFLICT (username) DO NOTHING;

-- Channels
INSERT INTO chat_sessions (id, name, type, description, is_public)
VALUES
    ('general','General','channel','Welcome to the galaxy hub', TRUE)
    ON CONFLICT (id) DO NOTHING;

INSERT INTO chat_sessions (id, name, type, description, is_public)
VALUES
    ('tech','Tech-Talk','channel','Quantum computing & AI', TRUE)
    ON CONFLICT (id) DO NOTHING;

INSERT INTO chat_sessions (id, name, type, description, is_public)
VALUES
    ('news','Space-News','channel','Latest from the cosmos', TRUE)
    ON CONFLICT (id) DO NOTHING;

INSERT INTO chat_sessions (id, name, type, description, is_public)
VALUES
    ('random','Random','channel','Memes and stardust', TRUE)
    ON CONFLICT (id) DO NOTHING;

-- Example: insert an initial system message into 'general'
DO $$
    DECLARE
        sys_id UUID;
    BEGIN
        -- Ambil ID dari user System
        SELECT id INTO sys_id FROM users WHERE username = 'System' LIMIT 1;

        -- Lakukan insert jika user ditemukan
        IF sys_id IS NOT NULL THEN
            INSERT INTO messages (chat_session_id, sender_id, sender_name, text, timestamp, status, avatar)
            VALUES ('general', sys_id, 'System', 'Welcome to the NebulaChat General Channel. ðŸš€', now() - interval '3 days', 'sent', 'SY')
            ON CONFLICT DO NOTHING;
        END IF;
    END $$;

-- NOTE:
-- - Frontend sets "isOwn" client-side by comparing currentUser to message.sender_name or sender_id.
-- - Attachments: frontend currently uses base64 data URLs; recommended flow:
--   1) Frontend uploads file to backend (multipart/form-data).
--   2) Backend stores file in object storage (S3/GCS) and stores the URL in attachments.url
--   3) Optionally store small binary in data (BYTEA) or store base64 in data_base64 for quick prototyping.